generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "sqlite"
}

// ============================================================
// BetterAuth tables (managed by better-auth)
// ============================================================

model User {
  id            String    @id
  name          String
  email         String    @unique
  emailVerified Boolean   @default(false)
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  sessions     Session[]
  accounts     Account[]

  bankAccounts     BankAccount[]
  statements       BankStatement[]
  transactions     Transaction[]
  settings         UserSettings?
  memories         UserMemory[]
  processingJobs   ProcessingJob[]
  chatThreads      ChatThread[]
  chatTraces       ChatTrace[]
  plaidConnections      PlaidConnection[]
  documents             Document[]
  jobs                  Job[]
  googleDriveConnection GoogleDriveConnection?
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@index([userId])
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier])
}

// ============================================================
// App tables (ported from keeping-books)
// ============================================================

model UserSettings {
  id                 String   @id @default(uuid())
  userId             String   @unique
  user               User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  fiscalYearEndMonth Int      @default(12)
  fiscalYearEndDay   Int      @default(31)
  bankTimezone       String   @default("America/Vancouver")
  userTimezone       String   @default("America/Vancouver")
  aiContext          String?
  aiModel            String   @default("openai/gpt-4o-mini")
  plaidClientId      String?  // Self-hosted: user's own Plaid client ID
  plaidSecret        String?  // Self-hosted: user's own Plaid secret
  plaidEnvironment   String   @default("sandbox") // sandbox | development | production
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
}

model UserMemory {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  key       String
  value     String
  category  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, key])
  @@index([userId, category])
}

model BankAccount {
  id            String   @id @default(uuid())
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  accountNumber String
  nickname      String
  bankName      String?
  currency      String   @default("CAD")
  accountType   String   @default("chequing")
  ownershipType String   @default("personal")
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  statements BankStatement[]

  @@unique([userId, accountNumber])
  @@index([userId])
}

model BankStatement {
  id                 String    @id @default(uuid())
  userId             String
  user               User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  bankAccountId      String?
  bankAccount        BankAccount? @relation(fields: [bankAccountId], references: [id])
  fileName           String
  fileUrl            String
  fileSize           Int
  contentHash        String?
  duplicateOf        String?
  bankName           String
  accountNumber      String?
  statementDate      DateTime?
  periodStart        DateTime?
  periodEnd          DateTime?
  openingBalance     Float?
  closingBalance     Float?
  totalDeposits      Float?
  totalWithdrawals   Float?
  status             String    @default("pending") // pending | processing | done | error
  errorMessage       String?
  isProcessed        Boolean   @default(false)
  processedAt        DateTime?
  processingTimezone String?
  verificationStatus String?
  discrepancyAmount  Float?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  transactions        Transaction[]
  balanceVerification BalanceVerification?
  processingJobs      ProcessingJob[]

  @@index([userId])
  @@index([contentHash])
  @@index([status])
}

model Transaction {
  id              String         @id @default(uuid())
  userId          String
  user            User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  statementId     String?
  statement       BankStatement? @relation(fields: [statementId], references: [id], onDelete: Cascade)
  transactionDate DateTime
  description     String
  amount          Float
  balance         Float?
  transactionType String         @default("debit")
  category        String?
  referenceNumber String?
  sortOrder       Int?
  source          String         @default("statement") // "manual" | "statement" | "plaid"
  plaidId         String?        // Plaid transaction ID for dedup
  isProvisional   Boolean        @default(false)
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  @@unique([statementId, transactionDate, description, amount, balance])
  @@index([userId, transactionDate])
  @@index([statementId])
  @@index([category])
  @@index([plaidId])
}

model BalanceVerification {
  id                        String   @id @default(uuid())
  statementId               String   @unique
  statement                 BankStatement @relation(fields: [statementId], references: [id], onDelete: Cascade)
  calculatedOpeningBalance  Float
  calculatedClosingBalance  Float
  statementOpeningBalance   Float
  statementClosingBalance   Float
  isBalanced                Boolean
  discrepancyAmount         Float?
  verificationDate          DateTime @default(now())
  notes                     String?
  createdAt                 DateTime @default(now())
  updatedAt                 DateTime @updatedAt
}

model ProcessingJob {
  id          String    @id @default(uuid())
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  statementId String?
  statement   BankStatement? @relation(fields: [statementId], references: [id])
  fileName    String
  status      String    @default("pending")
  errorMessage String?
  startedAt   DateTime?
  completedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  logs ProcessingLog[]

  @@index([userId])
  @@index([status])
}

model ProcessingLog {
  id             String   @id @default(uuid())
  jobId          String
  job            ProcessingJob @relation(fields: [jobId], references: [id], onDelete: Cascade)
  sequenceNumber Int
  logType        String
  title          String?
  content        String?
  createdAt      DateTime @default(now())

  @@index([jobId])
  @@index([jobId, sequenceNumber])
}

model ChatThread {
  id         String   @id @default(uuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  title      String?
  isArchived Boolean  @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  messages ChatMessage[]

  @@index([userId])
}

model ChatMessage {
  id         String   @id @default(uuid())
  threadId   String
  thread     ChatThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  role       String
  content    String
  toolCalls  String?
  toolCallId String?
  model      String?
  traceId    String?  // Langfuse trace ID for debugging
  createdAt  DateTime @default(now())

  @@index([threadId])
}

model ChatTrace {
  id             String   @id @default(uuid())
  userId         String
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  threadId       String?
  model          String
  inputTokens    Int?
  outputTokens   Int?
  totalTokens    Int?
  latencyMs      Int?
  finishReason   String?
  steps          String   // JSON: array of step data (tool calls, tool results, text)
  userMessage    String?  // The user's prompt that triggered this trace
  assistantText  String?  // The final assistant text output
  error          String?
  createdAt      DateTime @default(now())

  @@index([userId])
  @@index([threadId])
  @@index([createdAt])
}

// ============================================================
// Plaid integration
// ============================================================

model PlaidConnection {
  id              String    @id @default(uuid())
  userId          String
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  institutionId   String
  institutionName String
  accessToken     String    // TODO: encrypt at rest
  itemId          String    @unique
  cursor          String?   // Plaid sync cursor for incremental updates
  status          String    @default("active") // active | error | disconnected
  errorMessage    String?
  lastSyncedAt    DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@index([userId])
}

// ============================================================
// Google Drive integration
// ============================================================

model GoogleDriveConnection {
  id           String    @id @default(uuid())
  userId       String    @unique
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken  String
  refreshToken String
  expiresAt    DateTime
  email        String?   // Google account email for display
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
}

// ============================================================
// Document library
// ============================================================

model Document {
  id                String   @id @default(uuid())
  userId            String
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  fileName          String
  fileUrl           String   // Relative path under data/uploads/documents/
  fileSize          Int
  mimeType          String
  documentType      String   @default("other") // statement | tax | investment | receipt | other
  tags              String?  // Comma-separated tags
  description       String?
  googleDriveFileId String?  // Google Drive file ID for tracking imported files
  uploadedAt        DateTime @default(now())
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([userId])
  @@index([userId, documentType])
  @@index([googleDriveFileId])
}

// ============================================================
// Background jobs
// ============================================================

model Job {
  id             String    @id @default(cuid())
  userId         String
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  type           String    // "file_processing", "reprocessing", "plaid_sync"
  status         String    @default("pending") // pending, running, completed, failed
  progress       Int       @default(0) // 0-100
  totalItems     Int       @default(0)
  completedItems Int       @default(0)
  error          String?
  startedAt      DateTime?
  completedAt    DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  items JobItem[]

  @@index([userId])
}

model JobItem {
  id          String    @id @default(cuid())
  jobId       String
  job         Job       @relation(fields: [jobId], references: [id], onDelete: Cascade)
  fileName    String
  status      String    @default("pending") // pending, running, completed, failed
  error       String?
  startedAt   DateTime?
  completedAt DateTime?
  createdAt   DateTime  @default(now())

  @@index([jobId])
}
